{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../src/integrations/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import { captureException, getCurrentHub, withScope } from '@sentry/core';\nimport { Mechanism, SentryEvent, SentryWrappedFunction } from '@sentry/types';\nimport { isFunction } from '@sentry/utils/is';\nimport { htmlTreeAsString } from '@sentry/utils/misc';\nimport { serializeObject } from '@sentry/utils/object';\n\nconst debounceDuration: number = 1000;\nlet keypressTimeout: number | undefined;\nlet lastCapturedEvent: Event | undefined;\nlet ignoreOnError: number = 0;\n\n/** JSDoc */\nexport function shouldIgnoreOnError(): boolean {\n  return ignoreOnError > 0;\n}\n/** JSDoc */\nexport function ignoreNextOnError(): void {\n  // onerror should trigger before setTimeout\n  ignoreOnError += 1;\n  setTimeout(() => {\n    ignoreOnError -= 1;\n  });\n}\n\n/**\n * Instruments the given function and sends an event to Sentry every time the\n * function throws an exception.\n *\n * @param fn A function to wrap.\n * @returns The wrapped function.\n */\nexport function wrap(\n  fn: SentryWrappedFunction,\n  options: {\n    mechanism?: Mechanism;\n  } = {},\n  before?: SentryWrappedFunction,\n): any {\n  if (!isFunction(fn)) {\n    return fn;\n  }\n\n  try {\n    // We don't wanna wrap it twice\n    if (fn.__sentry__) {\n      return fn;\n    }\n\n    // If this has already been wrapped in the past, return that wrapped function\n    if (fn.__sentry_wrapped__) {\n      return fn.__sentry_wrapped__;\n    }\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    // Bail on wrapping and return the function as-is (defers to window.onerror).\n    return fn;\n  }\n\n  const sentryWrapped: SentryWrappedFunction = function(this: any): void {\n    if (before && isFunction(before)) {\n      before.apply(this, arguments);\n    }\n\n    const args = Array.prototype.slice.call(arguments);\n\n    try {\n      // Attempt to invoke user-land function\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame, it\n      //       means Raven caught an error invoking your application code. This is\n      //       expected behavior and NOT indicative of a bug with Raven.js.\n      const wrappedArguments = args.map((arg: any) => wrap(arg, options));\n\n      if (fn.handleEvent) {\n        return fn.handleEvent.apply(this, wrappedArguments);\n      } else {\n        return fn.apply(this, wrappedArguments);\n      }\n    } catch (ex) {\n      ignoreNextOnError();\n\n      withScope(async scope => {\n        scope.addEventProcessor(async (event: SentryEvent) => {\n          const processedEvent = { ...event };\n\n          if (options.mechanism) {\n            processedEvent.exception = processedEvent.exception || {};\n            processedEvent.exception.mechanism = options.mechanism;\n          }\n\n          processedEvent.extra = {\n            ...processedEvent.extra,\n            arguments: serializeObject(args, 2),\n          };\n\n          return processedEvent;\n        });\n\n        captureException(ex);\n      });\n\n      throw ex;\n    }\n  };\n\n  // Accessing some objects may throw\n  // ref: https://github.com/getsentry/sentry-javascript/issues/1168\n  try {\n    for (const property in fn) {\n      if (Object.prototype.hasOwnProperty.call(fn, property)) {\n        sentryWrapped[property] = fn[property];\n      }\n    }\n  } catch (_oO) {} // tslint:disable-line:no-empty\n\n  sentryWrapped.prototype = fn.prototype;\n  fn.__sentry_wrapped__ = sentryWrapped;\n\n  // Signal that this function has been wrapped/filled already\n  // for both debugging and to prevent it to being wrapped/filled twice\n  sentryWrapped.__sentry__ = true;\n  sentryWrapped.__sentry_original__ = fn;\n\n  return sentryWrapped;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param eventName the event name (e.g. \"click\")\n * @returns wrapped breadcrumb events handler\n */\nexport function breadcrumbEventHandler(eventName: string): (event: Event) => void {\n  return (event: Event) => {\n    // reset keypress timeout; e.g. triggering a 'click' after\n    // a 'keypress' will reset the keypress debounce so that a new\n    // set of keypresses can be recorded\n    keypressTimeout = undefined;\n\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors). Ignore if we've\n    // already captured the event.\n    if (lastCapturedEvent === event) {\n      return;\n    }\n\n    lastCapturedEvent = event;\n\n    // try/catch both:\n    // - accessing event.target (see getsentry/raven-js#838, #768)\n    // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly\n    //   can throw an exception in some circumstances.\n    let target;\n    try {\n      target = htmlTreeAsString(event.target as Node);\n    } catch (e) {\n      target = '<unknown>';\n    }\n\n    getCurrentHub().addBreadcrumb(\n      {\n        category: `ui.${eventName}`, // e.g. ui.click, ui.input\n        message: target,\n      },\n      {\n        event,\n        name: eventName,\n      },\n    );\n  };\n}\n\n/**\n * Wraps addEventListener to capture keypress UI events\n * @returns wrapped keypress events handler\n */\nexport function keypressEventHandler(): (event: Event) => void {\n  // TODO: if somehow user switches keypress target before\n  //       debounce timeout is triggered, we will only capture\n  //       a single breadcrumb from the FIRST target (acceptable?)\n  return (event: Event) => {\n    let target;\n\n    try {\n      target = event.target;\n    } catch (e) {\n      // just accessing event properties can throw an exception in some rare circumstances\n      // see: https://github.com/getsentry/raven-js/issues/838\n      return;\n    }\n\n    const tagName = target && (target as HTMLElement).tagName;\n\n    // only consider keypress events on actual input elements\n    // this will disregard keypresses targeting body (e.g. tabbing\n    // through elements, hotkeys, etc)\n    if (!tagName || (tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !(target as HTMLElement).isContentEditable)) {\n      return;\n    }\n\n    // record first keypress in a series, but ignore subsequent\n    // keypresses until debounce clears\n    if (!keypressTimeout) {\n      breadcrumbEventHandler('input')(event);\n    }\n    clearTimeout(keypressTimeout);\n\n    keypressTimeout = (setTimeout(() => {\n      keypressTimeout = undefined;\n    }, debounceDuration) as any) as number;\n  };\n}\n"]}