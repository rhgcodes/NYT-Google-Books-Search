{"version":3,"file":"backend.js","sourceRoot":"","sources":["../src/backend.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseBackend, Options, SentryError } from '@sentry/core';\nimport { SentryEvent, SentryEventHint, Severity, Transport } from '@sentry/types';\nimport { isDOMError, isDOMException, isError, isErrorEvent, isPlainObject } from '@sentry/utils/is';\nimport { supportsBeacon, supportsFetch } from '@sentry/utils/supports';\nimport { addExceptionTypeValue, eventFromPlainObject, eventFromStacktrace, prepareFramesForEvent } from './parsers';\nimport { computeStackTrace } from './tracekit';\nimport { BeaconTransport, FetchTransport, XHRTransport } from './transports';\n\n/**\n * Configuration options for the Sentry Browser SDK.\n * @see BrowserClient for more information.\n */\nexport interface BrowserOptions extends Options {\n  /**\n   * A pattern for error URLs which should not be sent to Sentry.\n   * To whitelist certain errors instead, use {@link Options.whitelistUrls}.\n   * By default, all errors will be sent.\n   */\n  blacklistUrls?: Array<string | RegExp>;\n\n  /**\n   * A pattern for error URLs which should exclusively be sent to Sentry.\n   * This is the opposite of {@link Options.blacklistUrls}.\n   * By default, all errors will be sent.\n   */\n  whitelistUrls?: Array<string | RegExp>;\n}\n\n/** The Sentry Browser SDK Backend. */\nexport class BrowserBackend extends BaseBackend<BrowserOptions> {\n  /**\n   * @inheritDoc\n   */\n  public install(): boolean {\n    // We are only called by the client if the SDK is enabled and a valid Dsn\n    // has been configured. If no Dsn is present, this indicates a programming\n    // error.\n    const dsn = this.options.dsn;\n    if (!dsn) {\n      throw new SentryError('Invariant exception: install() must not be called when disabled');\n    }\n\n    Error.stackTraceLimit = 50;\n\n    return true;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected setupTransport(): Transport {\n    if (!this.options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return super.setupTransport();\n    }\n\n    const transportOptions = this.options.transportOptions ? this.options.transportOptions : { dsn: this.options.dsn };\n\n    if (this.options.transport) {\n      return new this.options.transport(transportOptions);\n    } else if (supportsBeacon()) {\n      return new BeaconTransport(transportOptions);\n    } else if (supportsFetch()) {\n      return new FetchTransport(transportOptions);\n    }\n    return new XHRTransport(transportOptions);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async eventFromException(exception: any, hint?: SentryEventHint): Promise<SentryEvent> {\n    let event;\n\n    if (isErrorEvent(exception as ErrorEvent) && (exception as ErrorEvent).error) {\n      // If it is an ErrorEvent with `error` property, extract it to get actual Error\n      const ex = exception as ErrorEvent;\n      exception = ex.error; // tslint:disable-line:no-parameter-reassignment\n      event = eventFromStacktrace(computeStackTrace(exception as Error));\n    } else if (isDOMError(exception as DOMError) || isDOMException(exception as DOMException)) {\n      // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)\n      // then we just extract the name and message, as they don't provide anything else\n      // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n      // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n      const ex = exception as DOMException;\n      const name = ex.name || (isDOMError(ex) ? 'DOMError' : 'DOMException');\n      const message = ex.message ? `${name}: ${ex.message}` : name;\n\n      event = await this.eventFromMessage(message, undefined, hint);\n      addExceptionTypeValue(event, message);\n    } else if (isError(exception as Error)) {\n      // we have a real Error object, do nothing\n      event = eventFromStacktrace(computeStackTrace(exception as Error));\n    } else if (isPlainObject(exception as {}) && hint && hint.syntheticException) {\n      // If it is plain Object, serialize it manually and extract options\n      // This will allow us to group events based on top-level keys\n      // which is much better than creating new group when any key/value change\n      const ex = exception as {};\n      event = eventFromPlainObject(ex, hint.syntheticException);\n      addExceptionTypeValue(event, 'Custom Object');\n    } else {\n      // If none of previous checks were valid, then it means that\n      // it's not a DOMError/DOMException\n      // it's not a plain Object\n      // it's not a valid ErrorEvent (one with an error property)\n      // it's not an Error\n      // So bail out and capture it as a simple message:\n      const ex = exception as string;\n      event = await this.eventFromMessage(ex, undefined, hint);\n      addExceptionTypeValue(event, `${ex}`);\n    }\n\n    event = {\n      ...event,\n      event_id: hint && hint.event_id,\n      exception: {\n        ...event.exception,\n        mechanism: {\n          handled: true,\n          type: 'generic',\n        },\n      },\n    };\n\n    return event;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async eventFromMessage(\n    message: string,\n    level: Severity = Severity.Info,\n    hint?: SentryEventHint,\n  ): Promise<SentryEvent> {\n    const event: SentryEvent = {\n      event_id: hint && hint.event_id,\n      level,\n      message,\n    };\n\n    if (this.options.attachStacktrace && hint && hint.syntheticException) {\n      const stacktrace = computeStackTrace(hint.syntheticException);\n      const frames = prepareFramesForEvent(stacktrace.stack);\n      event.stacktrace = {\n        frames,\n      };\n    }\n\n    return event;\n  }\n}\n"]}